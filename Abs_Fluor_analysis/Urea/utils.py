from pathlib import Path
from typing import Dict, List, Tuple, Union

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from loguru import logger
from scipy.optimize import curve_fit

# Curve fitting metrics
from scipy.stats import kendalltau, linregress
from sklearn.metrics import mean_squared_error
from tqdm import tqdm


def process_raw_excel(files: List[str], n_rows_skip: int) -> pd.DataFrame:
    """
    Reads and concatenates raw Excel files generated by Gen5 software of Synergy H1
    :param files: list, list of Excel files
    :param n_rows_skip: int, number of rows to skip
    :return: pd.DataFrame, concatenated Excel files
    """
    # Read excel files and concatenate
    raw_spectra = []
    for file in tqdm(files):
        logger.info(f"Processing {file}")

        raw_spectrum = (
            pd.read_excel(
                file,
                skiprows=n_rows_skip,
                usecols=lambda x: "Unnamed" not in x,
                index_col="Wavelength",
                engine="openpyxl",
            )
            .dropna()
            .drop(labels="Wavelength", axis=0)
        )
        raw_spectra.append(raw_spectrum)

    # Concatenate and convert to numeric
    final_spectrum = pd.concat(raw_spectra).apply(pd.to_numeric)

    # Adding numbering of measurement cycles
    final_spectrum["n"] = final_spectrum.groupby(final_spectrum.index).cumcount()

    return final_spectrum.reset_index()


def subtract_blanks(
    data: pd.DataFrame,
    blankwells_urea: List[str],
    blankwells_pbs: List[str],
    wells_urea: List[str],
    wells_pbs: List[str],
) -> pd.DataFrame:
    """
    Subtracts blank (elution buffer) values from the rest
    :param data: pd.DataFrame, the initial DataFrame
    :param blankwells_urea: list, list of wells with blank urea 9M values
    :param blankwells_pbs: list, list of wells with blank PBS values
    :param wells_urea: list, list of wells (with proteins, not blank) with urea
    :param wells_pbs: list, list of wells (with proteins, not blank) with PBS
    :return: pd.DataFrame, modified DataFrame with blank values subtracted
    """
    data = data.copy()
    # Subtract blank PBS
    data.loc[:, wells_pbs] = data.loc[:, wells_pbs].sub(
        data[blankwells_pbs].mean(axis=1), axis=0
    )
    # Subtract blank urea
    data.loc[:, wells_urea] = data.loc[:, wells_urea].sub(
        data[blankwells_urea].mean(axis=1), axis=0
    )
    return data


def plot_spectra(
    data: pd.DataFrame,
    genes: List[str],
    gene2wells: Dict[str, List[str]],
    spectra: str,
    urea: bool = True,
    figsize: Tuple[int, int] = (40, 16),
    output_directory: str = ".",
) -> None:
    """
    Plots and saves the absorbance or fluorescence measurement figures for the requested genes
    :param data: pd.DataFrame, dataframe containing data for requested genes
    :param genes: list, list of genes
    :param gene2wells: dictionary, assigns genes to the list of the wells
    :param spectra: str, absorbance or fluorescence
    :param urea: bool, True for urea, False for PBS
    :param figsize: tuple, determine size of figure
    :param output_directory: str, the output directory
    :return: None, saves the figure in the current directory
    """
    assert spectra.lower() in [
        "absorbance",
        "fluorescence",
    ], "Specify absorbance or fluorescence spectrum"

    # Number of rows and columns for the subplots
    nrows = len(genes)
    ncols = max(
        map(len, map(gene2wells.__getitem__, genes))
    )  # Taking max numbers of wells a gene has

    # Plotting
    plt.figure(figsize=figsize, dpi=200)

    for ind_gene, gene in enumerate(genes):
        assert gene in gene2wells.keys(), f"Gene {gene} not found"
        for ind_well, well in enumerate(gene2wells[gene]):
            plt.subplot(nrows, ncols, ind_gene * ncols + ind_well + 1)
            sns.lineplot(
                data=data,
                x=data.Wavelength,
                y=well,
                hue="n",
                ci=None,
                legend="brief",
                palette=sns.cubehelix_palette(start=0, rot=-0.5, as_cmap=True),
            )
            plt.title(f"cgre{gene} ({well})")
            plt.ylabel(
                f'{spectra} ({"9M urea" if urea == True else "PBS"})', fontsize=16
            )
            plt.xlabel("Wavelength", fontsize=16)
            plt.legend(frameon=False)  # Turns off frame on the legend
    plt.tight_layout()
    plt.savefig(
        Path(
            output_directory,
            f"{spectra}_{'9M_urea' if urea == True else 'PBS'}_cgre{'_'.join(genes)}",
        )
    )


def wells2genes(
    genes: List[str], gene2wells: Dict[str, List[set]], exclude_wells: List[str]
) -> Dict[str, str]:
    """
    Assigns gene to each well, returns dictionary well: gene
    :param genes: list, list of genes
    :param gene2wells: dictionary, each gene has a list of wells assigned
    :param exclude_wells: list, list of wells to exclude
    :return: dictionary, well: gene
    """
    wells2gene = {
        well: gene
        for gene in genes
        for well in gene2wells[gene]
        if well not in exclude_wells
    }
    return wells2gene


def conc_spectra(plt_wells2gene_data: Dict[int, List]) -> pd.DataFrame:
    """
    Concatenates the spectra from each plate into one DataFrame
    :param plt_wells2gene_data: dictionary, plate number (int) : list [wells to gene dictionary, dataframe for the plate
    :return: pd.DataFrame, united spectra dataframe
    """
    # Create the framework for the concatenated spectra
    spectra = pd.DataFrame(
        columns=[
            "gene",
            "wavelength",
            "signal",
            "treatment",
            "cycle",
            "replicate",
        ]
    )

    for wells2gene, data in plt_wells2gene_data.values():
        for well, gene in wells2gene.items():
            df = pd.DataFrame(
                {
                    "gene": gene,
                    "wavelength": data.Wavelength,
                    "signal": data[well],
                    "treatment": "urea" if int(well[1:]) < 7 else "pbs",
                    "cycle": data.n,
                    "replicate": f"{gene}_{well}",
                }
            )
            spectra = pd.concat([spectra, df])

    # Avoid 'duplicate axis' error
    return spectra.reset_index(drop=True)


def sigmoid(
    x: np.ndarray,
    L: Union[int, float],
    x0: Union[int, float],
    k: Union[int, float],
    b: Union[int, float],
) -> np.ndarray:
    """Return values from a general sigmoid function."""
    y = L / (1 + np.exp(-k * (x - x0))) + b

    return y


def exponential(
    x: np.ndarray, a: Union[int, float], b: Union[int, float]
) -> np.ndarray:
    """Return values from a general exponential function."""

    return a * np.exp(b * x)


def logarithmic(
    x: np.ndarray, a: Union[int, float], b: Union[int, float], c: Union[int, float]
) -> np.ndarray:
    """Return values from a general log function."""

    return a * np.log(b * (x + c))


def inverse_sigmoid(
    y: np.ndarray,
    L: Union[int, float],
    x0: Union[int, float],
    k: Union[int, float],
    b: Union[int, float],
) -> np.ndarray:
    """Return values from a general inverse sigmoid function."""
    x = -np.log(L / (y - b) - 1) / k + x0

    return x
